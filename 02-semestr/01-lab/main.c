// пункт 4.1

// #include <stdio.h>
// #include <stdint.h>

// static int32_t a = 12, b = 8, c = 34, d = 123;

// int main() {

//     printf("Исходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     a = (a + --b + --c + --d) / 2;
//     b *= 3;
//     c -= a % b;
//     d = (b&0xFE>>2) & (c&7>>2);

//     printf("Выходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     return 0;
// }

// пункт 4.2

// #include <stdio.h>
// #include <stdint.h>

// int main() {
//     int32_t a = 12, b = 8, c = 34, d = 123;

//     printf("Исходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     a = (a + --b + --c + --d) / 2;
//     b *= 3;
//     c -= a % b;
//     d = (b&0xFE>>2) & (c&7>>2);

//     printf("Выходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     return 0;
// }

// пункт 4.3

// #include <stdio.h>
// #include <stdint.h>

// int main() {
//     int32_t a, b, c, d;

//     scanf("%i %i %i %i", &a, &b, &c, &d);

//     printf("Исходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     a = (a + --b + --c + --d) / 2;
//     b *= 3;
//     c -= a % b;
//     d = (b&0xFE>>2) & (c&7>>2);

//     printf("Выходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     return 0;
// }

// пункт 4.4

// #include <stdio.h>
// #include <stdint.h>

// int main() {

//     /* В языке С оператор auto является наследием языка B 
//     и не несет никакого функционального смысла.
//         Если учесть, что методичка предполагает использование Borland
//     C++ 2006, то даже в таком случае оператор auto все еще остается
//     безполезным, т.к. новые возможности оператору auto добавили только
//     в редакции С++11, если, конечно, Borland не обновили оператор в своем
//     компиляторе раньше, чем вышла оффицальная редакция C++11.
//     В таком случае я предполагаю, что от нас требуется то, что написано ниже */

//     auto a, b, c, d;
//     printf("Исходные данные до присваивания:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     /* Нужно заметить, что конкретно использование оператора auto никак
//     не влияет на то, что будет хранится в переменных, а также какой размер
//     эти переменные будут иметь, здесь нужно понимать, что в C auto лишь
//     позволяет указать, что переменная должна быть видима не выше блока
//     (что кстати является поведением по умолчанию для всех переменных, кроме
//     тех, для которых указано другое поведение),
//     в котором она создана, тип же она примет int, что является наследственным
//     поведение из языка B, оставленным для простоты переноса кода. */
//     /* Значение переменных до присваивания обьясняется тем, что эти пространство
//     переменные выделяется еще в процессе компиляции. Переменные, значение
//     которых не обьявленно при создании, будут заполнены "мусором". */

//     scanf("%i %i %i %i", &a, &b, &c, &d);

//     printf("Исходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     a = (a + --b + --c + --d) / 2;
//     b *= 3;
//     c -= a % b;
//     d = (b&0xFE>>2) & (c&7>>2);

//     printf("Выходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     return 0;
// }

// пункт 4.5

// #include <stdio.h>
// #include <stdint.h>

// #include "main.h"

// int main() {

//     printf("Исходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     a = (a + --b + --c + --d) / 2;
//     b *= 3;
//     c -= a % b;
//     d = (b&0xFE>>2) & (c&7>>2);

//     printf("Выходные данные:\nA=%d, B=%d, C=%o, D=%o\n", a, b, c, d);

//     return 0;
// }

// пункт 4.6

// #include <stdio.h>
// #include <stdint.h>

// int32_t vars[4] = { 12, 8, 34, 123 };

// int main() {
//     printf("Исходные данные:\nA=%d, B=%d, C=%o, D=%o\n", vars[0], vars[1], vars[2], vars[3]);

//     vars[0] = (vars[0] + --vars[1] + --vars[2] + --vars[3]) / 2;
//     vars[1] *= 3;
//     vars[2] -= vars[0] % vars[1];
//     vars[3] = (vars[1]&0xFE>>2) & (vars[2]&7>>2);

//     printf("Выходные данные:\nA=%d, B=%d, C=%o, D=%o\n", vars[0], vars[1], vars[2], vars[3]);

//     return 0;
// }